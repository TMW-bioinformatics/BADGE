help(package="PTXQC")
rectarrows <- function(x0,y0,x1,y1,height,length,...) {
lwd=par("lwd")
l0=height*(y1-y0)/sqrt((x1-x0)^2+(y1-y0)^2)
l1=height*(x1-x0)/sqrt((x1-x0)^2+(y1-y0)^2)
d0=length*(y1-y0)/sqrt((x1-x0)^2+(y1-y0)^2)
d1=length*(x1-x0)/sqrt((x1-x0)^2+(y1-y0)^2)
polygon(x=c(x0+l0,x1+l0-d1,x1,x1-l0-d1,x0-l0),y=c(y0-l1,y1-l1-d0,y1,y1+l1-d0,y0+l1),...)
}
pval<-runif(6000, 0, 1)
logPval<--log(pval,base=10)
pos=1:6000
rsID<-paste("rs",1:6000,sep="")
data<-as.data.frame(cbind(pos,rsID,pval,logPval))
genes <- c( "NFIA", "KANK4", "DOCK7", "L1TD1")
gene.start<- c(4, 350, 1000, 2100)
gene.end<- c(3004, 3350, 4000, 5010)
genes.pos<- as.data.frame(cbind(genes, gene.start, gene.end))
genes.pos[,1]=as.character(genes.pos[,1])
genes.pos[,2]=as.numeric(as.character(genes.pos[,2]))
genes.pos[,3]=as.numeric(as.character(genes.pos[,3]))
lay=layout(matrix(seq(2),2,1,byrow=TRUE),heights=c(2000,1000))
par(mar=c(0,4.1,4.1,2.1))
plot(x=as.numeric(data$pos),y=as.numeric(as.character(data$logPval)),xaxt="n")
par(mar=c(5.1,4.1,0.5,2.1))
plot(0,0,type="n",xlim=c(min(pos),max(pos)),ylim=c(0,length(genes)*1.1),yaxt="n")
lapply(seq(length(genes)), function(i) {
rectarrows(genes.pos$gene.start[i],i,genes.pos$gene.end[i],i,col="blue",height=0.1,length=100) # change to length=1000 or length=10000 for large x-axes, as this is the length of the 'arrow' part of the rectangle
text(mean(c(genes.pos$gene.start[i],genes.pos$gene.end[i])),i+0.3,genes.pos$genes[i],cex=0.7)
})
figure
plot([1:5],[1:5]*3,'.-')
%// Say I want to put an arrow pointing to the location, [3 9]
text(2.94,8.3,'\uparrow','fontsize',20)
text(2.8,7.8,'point [3,9]')
x <- stats::runif(12); y <- stats::rnorm(12)
i <- order(x, y); x <- x[i]; y <- y[i]
plot(x,y, main = "arrows(.) and segments(.)")
## draw arrows from point to point :
s <- seq(length(x)-1)  # one shorter than data
arrows(x[s], y[s], x[s+1], y[s+1], col = 1:3)
s <- s[-length(s)]
segments(x[s], y[s], x[s+2], y[s+2], col = "pink")
xlim <- c(-5 , 5)
ylim <- c(-10, 10)
plot(0, type = "n", xlim = xlim, ylim = ylim,
main = "Arrows,  type = 'curved'")
x0 <- runif(100, xlim[1], xlim[2])
y0 <- runif(100, ylim[1], ylim[2])
x1 <- x0+runif(100, -1, 1)
y1 <- y0+runif(100, -1, 1)
Arrows(x0, y0, x1, y1, arr.length = runif(100), code = 2,
arr.type = "curved", arr.col = 1:100, lcol = 1:100)
plot(0, type = "n", xlim = xlim, ylim = ylim,
main = "Arrows,  type = 'circle'")
x0 <- runif(100, xlim[1], xlim[2])
y0 <- runif(100, ylim[1], ylim[2])
x1 <- x0 + runif(100, -1, 1)
y1 <- y0 + runif(100, -1, 1)
Arrows(x0, y0, x1, y1, arr.length = 0.2, code = 3,
arr.type = "circle", arr.col = "grey")
plot(0, type = "n", xlim = xlim, ylim = ylim,
main = "Arrows,  type = 'ellipse'")
Arrows(x0, y0, x1, y1, arr.length = 0.2, arr.width = 0.5,
code = 3, arr.type = "ellipse",  arr.col = "grey")
curve(expr = sin(x), 0, 2*pi+0.25, main = "Arrows")
x  <- seq(0, 2*pi, length.out = 10)
xd <- x + 0.025
Arrows(x, sin(x), xd, sin(xd), type = "triangle",
arr.length = 0.5, segment = FALSE)
xx <- seq(0, 10*pi, length.out = 1000)
plot(sin(xx)*xx, cos(xx)*xx, type = "l", axes = FALSE,
xlab = "", ylab = "", main = "Arrows,  type = 'curved'")
x  <- seq(0, 10*pi, length.out = 20)
x1 <- sin(x)*x
y1 <- cos(x)*x
xd <- x+0.01
x2 <- sin(xd)*xd
y2 <- cos(xd)*xd
Arrows(x1, y1, x2, y2, arr.type = "curved", arr.length = 0.4,
segment = FALSE, code = 1, arr.adj = 0.5 )
plot(sin(xx)*xx, cos(xx)*xx, type = "l", axes = FALSE,
xlab = "", ylab = "", main = "Arrows,  type = 'T'")
Arrows(x1, y1, x2, y2, arr.type = "T", arr.length = 0.4,
code = 1, arr.lwd = 2)
rectarrows <- function(x0,y0,x1,y1,height,length,...) {
+     lwd=par("lwd")
+     l0=height*(y1-y0)/sqrt((x1-x0)^2+(y1-y0)^2)
+     l1=height*(x1-x0)/sqrt((x1-x0)^2+(y1-y0)^2)
+     d0=length*(y1-y0)/sqrt((x1-x0)^2+(y1-y0)^2)
+     d1=length*(x1-x0)/sqrt((x1-x0)^2+(y1-y0)^2)
+     polygon(x=c(x0+l0,x1+l0-d1,x1,x1-l0-d1,x0-l0),y=c(y0-l1,y1-l1-d0,y1,y1+l1-d0,y0+l1),...)
+ }
rectarrows <- function(x0,y0,x1,y1,height,length,...) {
lwd=par("lwd")
l0=height*(y1-y0)/sqrt((x1-x0)^2+(y1-y0)^2)
l1=height*(x1-x0)/sqrt((x1-x0)^2+(y1-y0)^2)
d0=length*(y1-y0)/sqrt((x1-x0)^2+(y1-y0)^2)
d1=length*(x1-x0)/sqrt((x1-x0)^2+(y1-y0)^2)
polygon(x=c(x0+l0,x1+l0-d1,x1,x1-l0-d1,x0-l0),y=c(y0-l1,y1-l1-d0,y1,y1+l1-d0,y0+l1),...)
}
rectarrows(1, 1, 2, 2, 4, 5)
histnorm3=function(COUNT, condition, ...)
{
if (length(COUNT)>0)
{
hist(COUNT, breaks = 100, freq=FALSE, main = paste("Histogram of" , condition), ...)
rug(COUNT)
COUNT.NA <- COUNT
COUNT.NA[COUNT.NA == -Inf] <- NA
mn <- mean(COUNT.NA, na.rm = TRUE)
stdev <- sd(COUNT.NA, na.rm = TRUE)
x <- COUNT
curve(dnorm(x, mean = mn, sd= stdev), add=TRUE, col="red", lty="dotted", xaxt="n")
quant <- quantile(COUNT.NA, na.rm = TRUE)
abline(v=quant[2], col="blue")
abline(v=quant[3], col="red")
abline(v=quant[4], col="blue")
mtext(paste("mean ", round(mn, 1), "; sd ", round(stdev, 1), "; N ", length(COUNT),sep=""), side=1, cex=.75)
return(quant)
} # fi
} # histnorm
#functions####################################################################################
#settings
quantil_normalization <- TRUE
shift1 <- FALSE
p.sig <- 0.00005
p.high.sig <- 0.00001
#step 1 read data remove contaminants#########################################################################
#read experimental data
raw.data <- read.table("proteinGroups.txt", header=TRUE, sep="\t", comment.char = "")
#read metadata experimental design
meta.data <- read.table("SampleID_MSMS_AS.csv", header=TRUE, sep=";", comment.char = "", stringsAsFactors = FALSE)
#experimental design (replicates are labeled identically)
message("Number of samples: ", length(meta.data$condition))
#remove contaminants
step1.raw.data.nocont<- raw.data[!(raw.data$Only.identified.by.site=="+" | raw.data$Reverse=="+" | raw.data$Potential.contaminant=="+"), ]
protein.IDs <- step1.raw.data.nocont$Protein.IDs
#get fasta description if needed
headers <- as.data.frame(step1.raw.data.nocont$Fasta.headers)
rownames(headers) <- protein.IDs
#extract intensity columns
step1.data<- step1.raw.data.nocont[ , grepl( 'Reporter.intensity.[0-9].P' , names( step1.raw.data.nocont ) ) ]
#use protein accessions (IDs) as label
rownames(step1.data) <- protein.IDs
# Rename columns
for (i in 1:length(meta.data$ID.raw)) {
colnames(step1.data)[colnames(step1.data)==meta.data$ID.raw[i]] <- meta.data$ID.sample[i]
}
step2.data<-step1.data
#step 2 remove zero rows and separate zero blocks###############################################
# remove rows with 0s only
step2.data<- step2.data[!rowSums(!step2.data)==ncol(step2.data), ]
histnorm3(rowSums(step2.data==0), "data zero blocks distribution")
#move 0 blocks to new dataframe
step2.data.nozeroblocks<- step2.data[!(rowSums(!step2.data[, 1:10])==10 | rowSums(!step2.data[, 11:20])==10 | rowSums(!step2.data[, 21:30])==10 | rowSums(!step2.data[, 31:40])==10 | rowSums(!step2.data[, 41:50])==10), ]
step2.data.zeroblocks<- step2.data[(rowSums(!step2.data[, 1:10])==10 | rowSums(!step2.data[, 11:20])==10 | rowSums(!step2.data[, 21:30])==10 | rowSums(!step2.data[, 31:40])==10 | rowSums(!step2.data[, 41:50])==10), ]
histnorm3(rowSums(step2.data.nozeroblocks==0), "data no zero blocks")
#continue wich data with no zero blocks
step3.data <- step2.data.nozeroblocks
#step 3 between run normalisation##############################################################
## Hannes normalization #######################################################################
#normalize runs (replicates are labeled differently)
#get position of PS for run normalization
PS1.pos <- grep("PS1", colnames(step3.data))
PS2.pos <- grep("PS2", colnames(step3.data))
PS.pos <- c(PS1.pos, PS2.pos)
runs <- length(PS1.pos)
#calculate row means
all_row_means<- rowMeans(step3.data[, PS.pos], na.rm = FALSE, dims = 1)
all_row_means[is.na(all_row_means)]
#test for na in data
if (!isempty(step3.data[is.na(step3.data)])) {
warning("step3.data contains non numeric elements")
}
for(i in 1:runs) {
j <- i-1
row_means <- (step3.data[ ,PS1.pos[i]] + step3.data[ , PS2.pos[i]])/2
#shift data 1 up (remove zeros)
if (shift1) {
row_means <- row_means + 1
}
norm_factor <- all_row_means/row_means
histnorm3(norm_factor, paste("normfactor before outlier elimination: run ",  i))
#test for na's in dataset
if (!isempty(norm_factor[is.na(norm_factor)])) {
warning("norm_factor contains non numeric elements")
}
if (!isempty(norm_factor[is.infinite(norm_factor)])) {
warning("norm_factor contains infinite elements")
}
#quantile normalization
if (quantil_normalization) {
quant <- quantile(norm_factor, c(0.00, 0.01, 0.50, 0.99), na.rm = TRUE)
norm_factor[is.na(norm_factor)] <- quant[2]
norm_factor[is.infinite(norm_factor)] <- quant[4]
norm_factor[norm_factor < quant[2]] <- quant[2]
norm_factor[norm_factor > quant[4]] <- quant[4]
}
# simple normfactor gap filling by 1
else {
norm_factor[is.na(norm_factor)] <- 1
norm_factor[is.infinite(norm_factor)] <- 1
}
if (!isempty(norm_factor[is.na(norm_factor)])) {
warning("norm_factor contains non numeric elements")
}
step3.data[, (1+j*10):(10+j*10)] <- apply(step3.data[, (1+j*10):(10+j*10)], 2, "*", norm_factor)
histnorm3(norm_factor, paste("normfactor after outlier elimination: run ",  i))
}
# in rows with only 0 counts/intensities a division by 0 leads to NaN (replace by 0 again)
if (!isempty(step3.data[is.na(step3.data)])) {
warning("step3.data contains non numeric elements")
}
# only true samples are procecced further (10plex, first two are always calibration standards)
step3.data.filter <- step3.data[, c(3:10, 13:20, 23:30, 33:40, 43:49)]
## Hannes normalization end#######################################################################
#sort columns (we don't need experiment blocks any more)
step3.data.filter<- step3.data.filter[ , order(names(step3.data.filter))]
step4.data <- step3.data.filter
histnorm3(as.matrix(step4.data), "step4.data runs normalised")
#step 4 between sample normalisation##############################################################
## DESeq normalization #######################################################################
#normalize samples (replicates are labeled equal)
# for analysis float values are converted to int (count data)
step4.data.int <- round(step4.data, digits=0)
#remove PS and blanks from meta.data
meta.data.noPS <- meta.data[!(meta.data$condition == "PS" | meta.data$condition == "blank"), ]
meta.data.noPS.sort <- meta.data.noPS[order(meta.data.noPS$ID.sample), ]
#create cds object
cds = newCountDataSet(step4.data.int, meta.data.noPS.sort$condition)
cds = estimateSizeFactors(cds)
#print plot size factors
sizeFactors(cds)
plot(sizeFactors(cds))
# normalized count data
step4.data.norm <- counts(cds, normalized=TRUE)
## DESeq normalization end#####################################################################
histnorm3(step4.data.norm, "step4.data DESeq normalised")
step5.data <- step4.data.norm
#step 5 log2 transform ########################################################################
# log transform
if (TRUE) {
step5.data <- log2(step5.data)
step5.data[step5.data == -Inf] <- 0
}
step6.data <- step5.data
histnorm3(step6.data, "step6.data log2 transformed")
#step 6 transpose data ########################################################################
#transpose data
step6.data.t  <- as.data.frame(t(step6.data))
step6.data.t.cond <- as.data.frame(cbind(meta.data.noPS.sort$condition, step6.data.t))
colnames(step6.data.t.cond)[colnames(step6.data.t.cond)=="meta.data.noPS.sort$condition"] <- "condition"
step7.data <- step6.data.t.cond
#step 7 transpose data ########################################################################
#withingroupvariance
apply(step7.data[,2:4],2,function(x) tapply(x, step7.data$condition ,var))
#betweengroupvariance
apply(apply(step7.data[,2:4],2,function(x) tapply(x,step7.data$condition,var)),2,mean)
#TODO:do anything
#remove 0
step7.data[step7.data == 0] <- NA
protein.IDs.contain.zero<- colnames(step7.data[apply(step7.data, 2, function(x) any(x %in% NA))])
#anova analysis
fit.pvalues <- apply(step7.data[,2:ncol(step7.data)],2, function(x) summary(aov (x ~ condition, data = step7.data))[[1]][[1,"Pr(>F)"]])
fit.tukey.hsd <- as.data.frame(t(apply(step7.data[,2:ncol(step7.data)],2, function(x) t(as.data.frame(extract_p(TukeyHSD(aov (x ~ condition, data = step7.data))))))))
anova.step7.data  <- cbind(fit.pvalues, fit.tukey.hsd)
#naming of anova test
combos <- combn(levels(as.factor(meta.data.noPS.sort$condition)),2)
condition.combinations <- paste(combos[1, ], combos[2, ], sep="-")
cond.string <- c("ANOVA-P-VALUE")
anova.colnames <- c(cond.string, condition.combinations)
colnames(anova.step7.data) <- anova.colnames
write.table(anova.step7.data, file = "anova.step7.data.csv", sep=";", dec=".", row.names = TRUE, col.names = NA)
#log2 fold changes
step7.data.mean <- t(step7.data[, -1])
step7.data.mean[step7.data.mean == 0] <- NA
for (i in 1:13) {
j <- i-1
tmp.mean <- apply(step7.data.mean[, (1+j*3):(3+j*3)], 1, mean, na.rm=TRUE)
tmp.sd <- apply(step7.data.mean[, (1+j*3):(3+j*3)], 1, sd, na.rm=TRUE)
if (i == 1) {
condition.protein.sd <- tmp.sd
condition.protein.mean <- tmp.mean
} else {
condition.protein.sd <- cbind(condition.protein.sd, tmp.sd)
condition.protein.mean <- cbind(condition.protein.mean, tmp.mean)
}
}
step7.condition.protein.sd <- as.data.frame(condition.protein.sd)
colnames(step7.condition.protein.sd) <- levels(as.factor(meta.data.noPS.sort$condition))
step7.condition.protein.mean <- as.data.frame(condition.protein.mean)
colnames(step7.condition.protein.mean) <- levels(as.factor(meta.data.noPS.sort$condition))
#create combinations
condition.names <- levels(as.factor(meta.data.noPS.sort$condition))
for (i in 1:length(condition.names)) {
condition.names.variable <- condition.names[-i]
condition.name.fix <- condition.names[i]
for (j in 1:length(condition.names.variable)) {
if (i == 1 & j == 1) {
combos <- rbind(condition.name.fix, condition.names.variable[j])
} else {
combos.tmp <- rbind(condition.name.fix, condition.names.variable[j])
combos <- cbind(combos, combos.tmp)
}
}
}
#hier weiter morgen!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
log2fold.changedata<- apply(combos, 2, function(x) {
log2fold.change <- (step7.condition.protein.mean[, x[1]]/step7.condition.protein.mean[, x[2]])
return(log2fold.change)
})
step7.log2fold.changedata<- as.data.frame(log2fold.changedata)
colnames(step7.log2fold.changedata) <- paste(combos[1, ], combos[2, ], sep="-")
rownames(step7.log2fold.changedata) <- colnames(step7.data[-1])
histnorm3(as.matrix(step7.log2fold.changedata), "log2fold change")
step8.data <- step7.data
#step 8 gerneral filter data ########################################################################
anova.step8.data.notsig<- anova.step7.data[anova.step7.data$`ANOVA-P-VALUE` >= p.sig, ]
anova.step8.data.sig<- anova.step7.data[anova.step7.data$`ANOVA-P-VALUE` < p.sig, ]
anova.step8.data.highsig<- anova.step8.data.sig[anova.step8.data.sig$`ANOVA-P-VALUE` < p.high.sig, ]
#extract all intensity values
proteinIDnotsig<- rownames(anova.step8.data.notsig)
step8.data.notsig<- step8.data[, proteinIDnotsig]
proteinIDsig<- rownames(anova.step8.data.sig)
step8.data.sig<- step8.data[, proteinIDsig]
proteinIDhighsig<- rownames(anova.step8.data.highsig)
step8.data.highsig<- step8.data[, proteinIDhighsig]
#extract intensity values per condition
condition.names <- levels(as.factor(meta.data.noPS.sort$condition))
sig.levels <- c("highsig", "sig", "notsig")
sig.values <- c(p.high.sig, p.sig, 1)
path <- "conditions"
dir.create(path)
R.dir <- getwd()
setwd(path)
conditions.dir <- getwd()
for (condition.name in condition.names) {
dir.create(condition.name)
setwd(condition.name)
for (i in 1:length(sig.levels)) {
cmd <- paste("anova.step8.data.", sig.levels[i], "[ , grepl( condition.name , names( anova.step8.data.", sig.levels[i], ") ) ]", sep = "")
condition<- eval(parse(text = cmd))
if (sig.levels[i] == "notsig") {
names.condition<- rownames(condition)
condition.data<- step8.data[, names.condition]
write.table(condition, file = paste(condition.name, "_anova_", sig.levels[i], ".csv", sep=""), sep=";", dec=".", row.names = TRUE, col.names = NA)
write.table(condition.data, file = paste(condition.name, "_anova_data_", sig.levels[i], ".csv", sep=""), sep=";", dec=".", row.names = TRUE, col.names = NA)
} else {
#any
condition.any <- condition[apply(condition[, -1], MARGIN = 1, function(x) any(x < sig.values[i])), ]
names.condition.any<- rownames(condition.any)
condition.any.data<- step8.data[, names.condition.any]
if (!isempty(names.condition.any)) {
write.table(condition.any, file = paste(condition.name, "_anova_any_", sig.levels[i], ".csv", sep=""), sep=";", dec=".", row.names = TRUE, col.names = NA)
write.table(condition.any.data, file = paste(condition.name, "_anova_any_data_", sig.levels[i], ".csv", sep=""), sep=";", dec=".", row.names = TRUE, col.names = NA)
}
#all
condition.all <- condition[apply(condition[, -1], MARGIN = 1, function(x) all(x < sig.values[i])), ]
names.condition.all<- rownames(condition.all)
condition.all.data<- step8.data[, names.condition.all]
#message(names.condition.all)
if (!isempty(names.condition.all)) {
write.table(condition.all, file = paste(condition.name, "_anova_all_", sig.levels[i], ".csv", sep=""), sep=";", dec=".", row.names = TRUE, col.names = NA)
write.table(condition.all.data, file = paste(condition.name, "_anova_all_data_", sig.levels[i], ".csv", sep=""), sep=";", dec=".", row.names = TRUE, col.names = NA)
}
}
}
setwd(conditions.dir)
}
setwd(R.dir)
rm(condition.names, condition.all)
setwd("~/BADGE")
